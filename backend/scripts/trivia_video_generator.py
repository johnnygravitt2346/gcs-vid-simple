#!/usr/bin/env python3
"""
Integrated Trivia Video Generator - Works with Gemini Questions

This script integrates with the Trivia Factory pipeline to generate videos
directly from Gemini-generated questions without requiring CSV conversion.

Usage:
    python3 trivia_video_generator.py --questions_json questions.json --templates_dir ./assets --out_dir ./output

Requirements:
    - ffmpeg, ffprobe installed and on PATH
    - Pillow for text rendering
    - google-cloud-storage for asset management
    - google-cloud-texttospeech for TTS generation
"""

import json
import os
import sys
import argparse
from pathlib import Path
from typing import List, Dict, Any

# Add parent directory to path for imports
sys.path.append(str(Path(__file__).parent.parent))

from src.video_generator import VideoGenerator
from src.gemini_generator import GeminiQuestionGenerator

def load_questions_from_json(json_path: str) -> List[Dict[str, Any]]:
    """Load questions from JSON file generated by Gemini."""
    try:
        with open(json_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        # Handle different JSON structures
        if isinstance(data, list):
            return data
        elif isinstance(data, dict) and 'questions' in data:
            return data['questions']
        else:
            raise ValueError("Invalid JSON structure")
            
    except Exception as e:
        print(f"Error loading questions: {e}")
        sys.exit(1)

def main():
    parser = argparse.ArgumentParser(description="Generate trivia videos from Gemini questions")
    parser.add_argument("--questions_json", required=True, help="Path to JSON file with Gemini questions")
    parser.add_argument("--templates_dir", default="./assets", help="Directory containing video templates")
    parser.add_argument("--out_dir", default="./output", help="Output directory for videos")
    parser.add_argument("--font", help="Path to font file")
    parser.add_argument("--quality", default="medium", choices=["low", "medium", "high"])
    parser.add_argument("--fps", type=int, default=30)
    
    args = parser.parse_args()
    
    # Validate inputs
    if not os.path.exists(args.questions_json):
        print(f"Error: Questions file not found: {args.questions_json}")
        sys.exit(1)
    
    if not os.path.exists(args.templates_dir):
        print(f"Error: Templates directory not found: {args.templates_dir}")
        sys.exit(1)
    
    # Load questions
    print(f"Loading questions from {args.questions_json}")
    questions = load_questions_from_json(args.questions_json)
    print(f"Loaded {len(questions)} questions")
    
    # Initialize video generator
    config = {
        "video": {
            "quality": args.quality,
            "fps": args.fps,
            "resolution": "1920x1080"
        }
    }
    
    generator = VideoGenerator(config)
    
    # Prepare video generation request
    request = VideoGenerator.VideoGenerationRequest(
        questions=questions,
        template_path=args.templates_dir,
        output_dir=args.out_dir,
        font_path=args.font or "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf"
    )
    
    try:
        # Generate videos
        print("Generating video clips...")
        clips = await generator.generate_videos(request)
        
        print(f"Generated {len(clips)} video clips")
        
        # Concatenate final video
        final_output = os.path.join(args.out_dir, "final_video.mp4")
        print("Concatenating final video...")
        
        final_video = await generator.concatenate_final_video(clips, final_output)
        print(f"Final video created: {final_video}")
        
        # Print summary
        print("\n" + "="*50)
        print("VIDEO GENERATION COMPLETE")
        print("="*50)
        print(f"Questions processed: {len(questions)}")
        print(f"Clips generated: {len([c for c in clips if c.status == 'completed'])}")
        print(f"Final video: {final_video}")
        print(f"Output directory: {args.out_dir}")
        
    except Exception as e:
        print(f"Error during video generation: {e}")
        sys.exit(1)
    finally:
        generator.cleanup()

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())
